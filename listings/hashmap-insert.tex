\begin{lstlisting}[
label=lst:hashmap-insert,
caption=Implementation of \code{HashMap::insert}.,
numbers=left, numberstyle=\color{gray}\ttfamily{}HI,
escapeinside={@*}{*@}
]
impl<K, V> HashMap<K, V> {
    pub fn insert(&self, k: K, v: V) {
        let (bucket, rev_hash) = self.bucket_and_revhash(&k);
        let node_data = Entry::Value((rev_hash, k, v));
        let curr = self.get_or_insert_bucket(bucket);
        guards!(_new_node, _curr, _prev);
        let mut new_node = cmr::alloc(_new_node, list::Node::new(node_data));
        'restart: loop {
            let mut entry = list::Entry::from_node_ptr(curr, _curr, _prev);
            if entry.seek_with(|entry| entry.hash() >= rev_hash).is_err() {
                @*$\big<\textit{\sffamily end of list case}\big>$*@
            }
            match entry.current().ptr().unwrap().data() {
                Entry::Sentinel(h) if *h == rev_hash => {
                    match entry.step() {
                        Err(list::Error::NotConsecutive) |
                        Err(list::Error::IllegalState) => continue 'restart,
                        _ => {} } }
                _ => {} }
            if entry.insert_between(new_node).is_err() { continue 'restart; }
            'outer: while let Some(curr) = entry.current().ptr() {
                if curr.data().hash() != rev_hash { break; }
                if curr.data().key() == new_node.data().key() {
                    loop {
                        let n = unsafe { curr.next.load(Ordering::SeqCst) };
                        if ptr::tag(n) == 1 { break 'outer; }
                        match curr.next.cas(n, ptr::with_tag(n, 1), Ordering::SeqCst) {
                            Ok(_) => break 'outer,
                            Err(p) if ptr::tag(p) == 1 => break 'outer,
                            _ => {}
                        }
                    }
                }
                let res = entry.step();
                if let Err(list::Error::IllegalState) = res { panic!("wtf"); }
            }
            break;
        }
        let c = self.count.fetch_add(1, Ordering::Relaxed);
        let len = self.length.load(Ordering::Relaxed);
        if c as f32 / len as f32 > THRESHOLD {
            if len * 2 > MAX_LEN { panic!("Aiai, this is a problem!"); }
            self.length.compare_and_swap(len, len * 2, Ordering::SeqCst);
        }
    }}
\end{lstlisting}
