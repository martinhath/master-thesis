\chapter{CMR}

We have named the system \emph{CMR}, short for \emph{Concurrent Memory Reclamation}. The system is
implemented as a Rust library \code{cmr}. We have also implemented four data structures, a stack,
queue, list, and hasmap, in the \code{cmr-data-structures} library, which uses \code{cmr}
internally for memory reclamation.

This chapter is organized as follows:
Section~\ref{sec:cmr-overview} gives an overview of the system as a whole, and defines the problem
we want to solve.
Section~\ref{sec:cmr-primitives} defines the primitives of the system, how they interact, and
proves their correctness.
\todo{bla}

\section{Problem Definition}

We define an abstract model of the system, and prove its correctness.
The computational model we are working with is the RAM machine, and assume that
the reader is familiar with it\footnote{\todo{Have def.\ in background?}}.

We start by defining some central concepts.
Memory $M$ is the set of all addresses in the address space of the machine.
It is a disjoint set $M = A \cap F$ where $A$ is the set of allocated memory, and $F$ is the
remaining of the memory space.
A \emph{block} is a tuple $(addr, size)$ and represents the memory segment $[addr, addr + size)$.
We call memory that is in an allocated block \emph{valid memory}.



\note{here we must know what allocation is, what freeing is, and how we think
about memory.}


We first define three memory hazards:

\begin{definition}[invalid-read]
  Memory that has never been allocated is read.
\end{definition}

\begin{definition}[use-after-free]
  Memory that was allocated and then freed is read.
\end{definition}

\begin{definition}[double-free]
  A block was freed twice without being allocated in between.
\end{definition}

We would like our system to guarantee that neither of the three happens.

\section{Overview\label{sec:cmr-overview}}

The high level idea of the system is for the consolidator to have easy access to all roots in every
thread. With this information, the problem of identifying garbage is equivalent to reachability
analysis in a graph in which the vertices are data types in the program and the edges are pointers.
 Having this, we can
identify the reachable segments $R \subseteq M$ and the garbage $G = M \setminus R$.

\begin{figure}[ht]
  \centering
  \begin{subfigure}{0.45\textwidth}
    \begin{lstlisting}
a = Node { value = 4, next = null }
b = Node { value = 8, next = a }
list = [a, b, 3]
    \end{lstlisting}
  \end{subfigure}
  \hfill
  \begin{subfigure}{0.45\textwidth}
    \input{figures/graph-reachability}
  \end{subfigure}
  \caption{Code sample (left) with possible heap layout (right). If the black filled node is the
  only root, the black nodes are reachable, and the gray nodes are not. Note that one node (z)
  points to a reachable node, but is itself not reachable.}
\end{figure}

Performing the reachability analisys is not straight forwars, even when we have all roots in the
system. Consider a mark-and-sweep approach, where we follow pointers and keep track of memory
locations that we have seen before. Since we are running a concurrent system, pointers might be
updated while we scan, so that two pointer values might be swapped after looking at either of them,
making the other value invisible to the system, and causing memory to be registered as unreachable,
when it is not.

\begin{figure}[ht]
  \centering
  \input{figures/pointer-swap}
  \caption{Illustration of how mutation in the reachability graph can make memory (b) appear as
  non-reachable. After we have looked at the roots left child, but before reading its right, the
  nodes child pointers are swapped. Since we cannot detect this (the two pointers could have been
  the same), we see (a) twice and do not see (b).}
\end{figure}

In order to handle mutation problems, we obtain a snapshot of the entire processes memory, by
freezing all threads, reading their guards, and forking the process. Thus, we have a snapshot of
the entire memory of the program, in which we also have all roots. Now the reachability analysis is
simpler, since there will be only one thread in the forked process, namely the garbage collecting
thread.

The system works in \emph{passes}; once in a while, execution of a thread is ``hijacked'' to
run a garbage collection pass instead of running the user code.
When the work is done the thread returns to the user code it was
originally running. All free calls happen inside a pass, and only one thread is in a path at any
time. Lemma~\ref{lm:valid-outside-pass} follows:
\begin{lemma}\label{lm:valid-outside-pass}
  Let $t\sb{1}$ and $t\sb{2}$ be time instants in the program, and let $t\sb{1} < t\sb{2}$.
  If a pointer $p$ is valid at $t\sb{1}$, and no pass happens in the time interval
  $[t\sb{1}, t\sb{2}]$, then $p$ is valid at $t\sb{2}$.
\end{lemma}





\todo{define ``Rust memory'' and shared memory}

\section{Primitives of CMR\label{sec:cmr-primitives}}

The central data type to achieve this is \code{Guard}. A \code{Guard} is an object in which a
pointer to shared memory is stored. All pointers to shared memory are stored in a Guard. By
having access to all \code{Guard}s, CMR have access to all roots. \code{Guard}s are similar to
hazard pointers, except that no thread synchronization is performed when making new or updating
existing \code{Guard}s, which reduces the overhead significantly.

CMR has four types that are essential to understanding how we manage safe access to shared memory:
\emph{Guard}, \emph{Atomic}, \emph{NullablePtr}, and \emph{Ptr}. All types are generic over the
same type, which is omitted for brevity. We look at each type in turn.

\begin{definition}[Guard]
  A \emph{Guard} is an object that contains a \emph{root}. The Guard is non-movable in memory.
  All roots are stored in Guards.
\end{definition}

\begin{definition}[Atomic]
  An \emph{Atomic} is a pointer variable that provides safe concurrent access.
\end{definition}

\begin{definition}[NullablePtr]
  \emph{NullablePtr} is an immutable pointer that may be $\bot$. It is obtained through a Guard.
  When a NullablePtr $p$ is obtained from a Guard $g$, $g$ is immutable thoughout the lifetime of
  $p$.
\end{definition}

\begin{definition}[Ptr]
  \emph{Ptr} is an immutable pointer that may \emph{not} be $\bot$. Its semantics are similar to
  that of NullablePtr, but the two are distinct types for simplification. All accesses to shared
  memory is through a Ptr.
\end{definition}


Having defined the types, we define the operations on the types:

\begin{definition}[Common operations]
\begin{equation}\label{eq:make-guard}
  \text{make-guard\:::\:} () \to Guard
\end{equation}
\emph{make-guard} constructs a new Guard variable containing $\bot$.

\begin{equation}\label{eq:load-atomic}
  \text{load-atomic\:::\:} (Guard, Atomic) \to NullablePtr
\end{equation}
\emph{load-atomic} reads the atomic vairable, protects it with the Guard, and return a NullablePtr
to the value read.
\end{definition}

\begin{definition}\label{def:atomic}
  $\text{atomic\:::\:} (() \to T) \to T$ is a higher order function that runs a function without
  a reclamation pass happening during the functions execution.
\end{definition}




With these types and operations we are able to prove important properties of the system.

\begin{theorem}[Guard is valid]\label{thm:guard-valid}
  If a Guard is not $\bot$, it points to valid memory.
\end{theorem}
\begin{proof}
  \note{lol}
  Assume the Guard $g$ $\neq \bot$.
  The Guard has loaded its value from an Atomic $a$ using $atomic-load$.
We first show that $a$ is itself in valid memory. By induction:
\emph{Base case:} the Atomic resides in Rust memory, and is thus valid. \emph{Inductive case:} the
Atomic resides in shared memory, and thus accessed through a Ptr $p$.  This Ptr is protected by a
Guard $g\sb{2} \neq g$, since $g\sb{2}$ is immutable throughout the lifetime of $p$, and $g$ is
being changed. $g\sb{2}$ is valid by induction, so the pointer value in $a$ is reachable.

Using Definition~\ref{def:atomic}, we make sure that the read of $a$ and the store in $g$ happens
without a reclamation pass in between. Thus all valid pointers before the read is still valid after
the store.  After the store operation in $g$ has completed, $g$ protects $v$. Thus $v$ is valid.
\end{proof}

\begin{lemma}[Ptr is valid]\label{lm:ptr-valid}
  The Ptr points to valid memory.
\end{lemma}
\begin{proof}
The  Ptr $p$ is read from a Guard $g$ and $g$ is immutable throughout the lifetime of $p$ so they
have the same value. $p \neq \bot$, so this follows by Theorem~\ref{thm:guard-valid}.
\end{proof}




\section{Implementation}

The key idea of the implementation is to use an operation known as \emph{forking} to obtain a
snapshot of the entire memory space of the process. Having this we can identify the roots, and run
reachability analysis, knowing that nothing will change while we are looking.

Consolidation starts by sending all running threads a \emph{signal}, causing them to jump to a
\emph{signal handler}. The signal handler registers that the thread has been signaled, such that the
garbage collection pass is detectable. Then the thread writes out the address of a thread local
list of allocated addresses, such that the consolidator can collect all addresses that has been
allocated since the last consolidation. At last, the threads wait for the consolidator to say that
they may return to their execution. \note{why is this required?}

\note{Add implementation details here}

  \code{WAS\_SIGNALED} is a thread local flag that is
  set to \code{true} in the signal handler. Note that this function does not support being called
  recursively.
\begin{figure}[ht]
  \begin{lstlisting}[numbers=left,numberstyle=\color{gray}\ttfamily{}A]
fn atomic(f: F):
  loop:
    WAS_SIGNALED = false
    let ret = f()
    if not WAS_SIGNALED: return ret
\end{lstlisting}
\caption{Pseudocode of $atomic$}
\end{figure}

\begin{theorem}
  If \code{f} does not itself call \code{atomic} then \code{atomic} satisfy
  Definition~\ref{def:atomic}.
\end{theorem}
\begin{proof}
  \code{WAS\_SIGNALED} is set to \code{false} in \code{A3}, so if it is observed to be
  \code{true} in \code{A5} the signal handler must have been executed. Since only the consolidator
  signals any thread, it means that there was a consolidator in this time interval. We are only
  returning from the function if \code{WAS\_SIGNALED = false}, so if we return \code{f} was
  successfully called without overlapping with a pass.
\end{proof}
Note that it is possible that the consolidator was initiated before entering the \code{atomic}
function, but that they only got execution time after \code{A3}.
\begin{lemma}
  If the consolidator is lock-free, then \code{atomic} is lock-free.
\end{lemma}
\begin{proof}
  If we loop, there is a consolidator. Since the consolidate process has a finite number of steps
  and is lock-free, it will either make progress, or some other thread is making progress. In
  either case, the system makes progress.
  \note{this is a terrible proof}
\end{proof}

It is important that the function given to \code{atomic} can be called multiple times without
breaking. The most useful case for \code{atomic} is a \code{load/store} store pair, so this is
usually the case.

