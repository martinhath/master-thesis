\chapter{CMR}

\section{Overview}

The high level idea of the system is for the consolidator to have easy access to all roots in every
thread. With this information, the problem of identifying garbage is equivalent to reachability
analysis in a graph in which the vertices are \code{struct}s and the edges are pointers.
\todo{image here}

The central data type to achieve this is \code{Guard}. A \code{Guard} is an object in which a
pointer to shared memory is stored. By having access to all \code{Guard}s, CMR have access to all
roots. \code{Guard}s are similar to hazard pointers, except that no thread synchronization is
performed when making new or updating existing \code{Guard}s, which reduces the overhead
significantly.

\vspace{2cm}

We define an abstract model of the system, and prove its correctness.
The computational model we are working with is the RAM machine, and assume that
the reader is familiar with it\footnote{\todo{Have def.\ in background?}}.

\note{here we must know what allocation is, what freeing is, and how we think
about memory.}

We would like our system to provide $n$ guarantees:

\begin{enumerate}
  \item No memory reads should be outside all allocated memory segments.
  \item No memory read should be in a memory segment that has been freed.
  \item No freed pointer should be freed again.
\end{enumerate}

We call a pointer that points to any part of an allocated memory segment \emph{valid}.


We start by defining some central concepts.
\begin{definition}[allocation]
  \emph{Allocation} is a function $\mathbb{Z} \to \mathbb{Z}$ that takes a
  size and returns a pointer. \note{it this really needed?}
\end{definition}


The system works in \emph{passes}; once in a while, execution of a thread is ``hijacked'' to not run
user code, but garbage collection. When the work is done the thread returns to the user code it was
originally running. All free calls happen inside a pass, and only one thread is in a path at any
time. Lemma~\ref{lm:valid-outside-pass} follows:
\begin{lemma}\label{lm:valid-outside-pass}
  Let $t\sb{1}$ and $t\sb{2}$ be time instants in the program, and let $t\sb{1} < t\sb{2}$.
  If a pointer $p$ is valid at $t\sb{1}$, and no pass happens in the time interval
  $[t\sb{1}, t\sb{2}]$, then $p$ is valid at $t\sb{2}$.
\end{lemma}


\vspace{2cm}

\todo{define ``Rust memory'' and shared memory}

\section{some name here}

CMR has four types that are essential to understanding how we manage safe access to shared memory:
\emph{Guard}, \emph{Atomic}, \emph{NullablePtr}, and \emph{Ptr}. All types are generic over the
same type, which is omitted for brevity. We look at each type in turn.

\begin{definition}[Guard]
  A \emph{Guard} is an object that contains a \emph{root}. The Guard is non-movable in memory.
  All roots are stored in Guards.
\end{definition}

\begin{definition}[Atomic]
  An \emph{Atomic} is a pointer variable that provides safe concurrent access.
\end{definition}

\begin{definition}[NullablePtr]
  \emph{NullablePtr} is an immutable pointer that may be $\bot$. It is obtained through a Guard.
  When a NullablePtr $p$ is obtained from a Guard $g$, $g$ is immutable thoughout the lifetime of
  $p$.
\end{definition}

\begin{definition}[Ptr]
  \emph{Ptr} is an immutable pointer that may \emph{not} be $\bot$. Its semantics are similar to
  that of NullablePtr, but the two are distinct types for simplification. All accesses to shared
  memory is through a Ptr.
\end{definition}


Having defined the types, we define the operations on the types:

\begin{definition}[Common operations]
\begin{equation}\label{eq:make-guard}
  \text{make-guard\:::\:} () \to Guard
\end{equation}
\emph{make-guard} constructs a new Guard variable containing $\bot$.

\begin{equation}\label{eq:load-atomic}
  \text{load-atomic\:::\:} (Guard, Atomic) \to NullablePtr
\end{equation}
\emph{load-atomic} reads the atomic vairable, protects it with the Guard, and return a NullablePtr
to the value read.
\end{definition}

\begin{definition}\label{def:atomic}
  $\text{atomic\:::\:} (() \to T) \to T$ is a higher order function that runs a function without
  a reclamation pass happening during the functions execution.
\end{definition}




With these types and operations we are able to prove important properties of the system.

\begin{theorem}[Guard is valid]\label{thm:guard-valid}
  If a Guard is not $\bot$, it points to valid memory.
\end{theorem}
\begin{proof}
  \note{lol}
  Assume the Guard $g$ $\neq \bot$.
  The Guard has loaded its value from an Atomic $a$ using $atomic-load$.
We first show that $a$ is itself in valid memory. By induction:
\emph{Base case:} the Atomic resides in Rust memory, and is thus valid. \emph{Inductive case:} the
Atomic resides in shared memory, and thus accessed through a Ptr $p$.  This Ptr is protected by a
Guard $g\sb{2} \neq g$, since $g\sb{2}$ is immutable throughout the lifetime of $p$, and $g$ is
being changed. $g\sb{2}$ is valid by induction, so the pointer value in $a$ is reachable.

Using Definition~\ref{def:atomic}, we make sure that the read of $a$ and the store in $g$ happens
without a reclamation pass in between. Thus all valid pointers before the read is still valid after
the store.  After the store operation in $g$ has completed, $g$ protects $v$. Thus $v$ is valid.
\end{proof}

\begin{lemma}[Ptr is valid]\label{lm:ptr-valid}
  The Ptr points to valid memory.
\end{lemma}
\begin{proof}
The  Ptr $p$ is read from a Guard $g$ and $g$ is immutable throughout the lifetime of $p$ so they
have the same value. $p \neq \bot$, so this follows by Theorem~\ref{thm:guard-valid}.
\end{proof}




\section{Implementation}

The key idea of the implementation is to use an operation known as \emph{forking} to obtain a
snapshot of the entire memory space of the process. Having this we can identify the roots, and run
reachability analysis, knowing that nothing will change while we are looking.

Consolidation starts by sending all running threads a \emph{signal}, causing them to jump to a
\emph{signal handler}. The signal handler registers that the thread has been signaled, such that the
garbage collection pass is detectable. Then the thread writes out the address of a thread local
list of allocated addresses, such that the consolidator can collect all addresses that has been
allocated since the last consolidation. At last, the threads wait for the consolidator to say that
they may return to their execution. \note{why is this required?}

\note{Add implementation details here}

  \code{WAS\_SIGNALED} is a thread local flag that is
  set to \code{true} in the signal handler. Note that this function does not support being called
  recursively.
\begin{figure}[ht]
  \begin{lstlisting}[numbers=left,numberstyle=\color{gray}\ttfamily{}A]
fn atomic(f: F):
  loop:
    WAS_SIGNALED = false
    let ret = f()
    if not WAS_SIGNALED: return ret
\end{lstlisting}
\caption{Pseudocode of $atomic$}
\end{figure}

\begin{theorem}
  If \code{f} does not itself call \code{atomic} then \code{atomic} satisfy
  Definition~\ref{def:atomic}.
\end{theorem}
\begin{proof}
  \code{WAS\_SIGNALED} is set to \code{false} in \code{A3}, so if it is observed to be
  \code{true} in \code{A5} the signal handler must have been executed. Since only the consolidator
  signals any thread, it means that there was a consolidator in this time interval. We are only
  returning from the function if \code{WAS\_SIGNALED = false}, so if we return \code{f} was
  successfully called without overlapping with a pass.
\end{proof}
Note that it is possible that the consolidator was initiated before entering the \code{atomic}
function, but that they only got execution time after \code{A3}.
\begin{lemma}
  If the consolidator is lock-free, then \code{atomic} is lock-free.
\end{lemma}
\begin{proof}
  If we loop, there is a consolidator. Since the consolidate process has a finite number of steps
  and is lock-free, it will either make progress, or some other thread is making progress. In
  either case, the system makes progress.
  \note{this is a terrible proof}
\end{proof}

It is important that the function given to \code{atomic} can be called multiple times without
breaking. The most useful case for \code{atomic} is a \code{load/store} store pair, so this is
usually the case.

