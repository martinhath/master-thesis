\chapter{CMR\label{ch:cmr}}

In this chapter we present a concurrent memory reclamation scheme called \emph{CMR}.  We define the
problem of memory management carefully in \cref{sec:cmr-problem-def}, in order to get a complete
understanding of which problem we set out to solve.  In \cref{sec:cmr-overview} we present an
abstract overview of CMR, in order to get a high level understanding of the system as a whole,
without having to think about technical or implementation details.  \cref{sec:cmr-primitives}
discusses the primitives and operations of CMR, and how they are used.  Finally in
\cref{sec:cmr-correctness} we argue for the correctness of the system as presented in this chapter.
By reasoning about CMR without an implementation we later aim to show that the implementation
(\cref{ch:implementation}) fits the description of the system as we define it in this chapter.



\section{Problem Definition\label{sec:cmr-problem-def}}

We start by defining some central concepts. Memory $M$ is the set of all addresses in the address
space of the machine. A \emph{block} is a tuple $(a, n)$ and represents the memory segment
$\left[a, a + n\right)$. $M$ is a disjoint set $M = A \cap F$ where $A$ is the set of
allocated blocks, and $F$ is the remaining of the memory space. $F$ needs not, and is almost never,
a consecutive segments, but simply all memory that is outside any allocated block. We call such
memory \emph{invalid}, and all memory in an allocated block \emph{valid}.  We model the program
memory as a graph $G = (A, E)$ where $(u, v) \in E$ iff there is a pointer in $u$ pointing to an
address in the segment $v$. That is, memory segments are the vertices, and pointers in the program
are the edges. See \cref{fig:memory-graph} for a possible memory layout with a graph.

\begin{figure}[ht]
  \centering
  \begin{subfigure}{0.45\textwidth}
    \begin{lstlisting}
a = Node { value = 4, next = null }
b = Node { value = 8, next = a }
list = [a, b, 3]
    \end{lstlisting}
  \end{subfigure}
  \hfill
  \begin{subfigure}{0.45\textwidth}
    \input{figures/graph-reachability}
  \end{subfigure}
  \caption{Code sample (left) with possible heap layout (right). If the black filled node is the
  only root, the black nodes are reachable, and the gray nodes are not.\label{fig:memory-graph}}
\end{figure}

As most programs need memory blocks of dynamic size, allocation and deallocation,
\emph{``freeing''}, is commonplace. The problem of memory management is to know when it is
\emph{safe} to free a memory block. We want to avoid the following memory hazards:

\begin{definition}[\egn{use-after-free\label{def:use-after-free}}]
  Memory that was allocated and then freed is read.
\end{definition}

\begin{definition}[\egn{invalid-read\label{def:invalid-read}}]
  Memory that has never been allocated is read.
\end{definition}

\begin{definition}[\egn{double-free\label{def:double-free}}]
  A block is freed twice without being allocated in between.
\end{definition}


\egn{use-after-free} is the most hazarous of the three, as program behaviour is often undefined
when freed values are read; in many language implementations undefined behavious means that the
entire program is illegal, and one cannot assume anything about its behaviour (see
\cref{sec:background-pl}). The consequence of \egn{use-after-free} usually ranges from reading
values that are unchanged from the time the block was freed, to mutation of memory that has been
reused.

\egn{invalid-access} is the least frequent of the three, as it requires the programmer to conjure a
pointer out of thin air, since it has never been allocated in the system. As with
\egn{use-after-free}, this is too is usually undefined, with similar consequences. Despite their
similarities we choose to have \egn{invalid-access} as a separate category, as pointer arithmetic
may lead to these hazards.

\egn{double-free} is technically not a memory hazard, as the operating system can check for the
validity of pointers that are freed, although this is often not done in practice. It is not clear
whether this is due to performance penalties of checking, or if it is primarily a legacy
bevhaviour; POSIXs definition of \code{free} states that it is undefined behaviour to pass a
non-allocated pointer to \code{free}\cite{posix}.

We aim to show that CMR guarantees that neither of the three memory hazards are possible.


\subsection{Shared Memory}

Newer languages like modern C++ and Rust aim to avoid having the programmer manage memory manually,
due to a long history of the consequences of memory hazards. For single threaded application, this
may be considered a problem with suggested solutions. Rusts ownership model and lifetime tracking
(\cref{ch:rust}), and similar methods from the C++ standard library, are proposed solutions.
However, the ownership model does not handle shared memory functionally, as objects in shared
memory might not have an owner responsible for its management. Despite not being a complete
solution, having ``solved'' single threaded memory management turns out to be of great help.

\begin{figure}[ht]
  \centering
  \input{figures/rust-shared-mem}
  \caption{Example of memory layout showing owned memory (beige) and shared memory (red). Types in
  shared memory may contain pointers to owned memory, and vice versa.\label{fig:rust-shared-mem}}
\end{figure}

We divide up $A$ into two disjoint parts: \emph{owned} and \emph{shared} memory.  Owned memory is
all memory which management is already handled by some system, like Rusts ownership model or the
smart pointers of C++. Shared memory is the memory in which the structures that is not modeled well
by other constructs live, like the nodes in a linked list.

A key idea to recognize is that despite data being in Shared memory, they might themselves own data
that is in Owned memory, like the binary tree in \cref{fig:rust-shared-mem}. The destruction of a
list node containing the binary tree will utilize the system for owned memory, and make sure that
the binary tree is cleaned up properly. It does not matter if the list node itself resided in owned
or shared memory.  With this distiction we can reduce our problem space significantly, as we only
have to worry about the small subset of $A$ that is shared memory.  Note that it is also possible
to have the data types that are referenced from shared memory but stored in owned memory, like the
pointer poining to \code{0xcafe} in \cref{fig:rust-shared-mem}.  This includes pointers on a stack
frame, but might also include a entry in a hashmap. It is these pointers that CMR aims to control.


\section{Overview\label{sec:cmr-overview}}

CMR is based on the idea that if we have access to all roots in the system at an instant, finding
the set of all reachable blocks $R$ from the set of roots $R\sb{0}$ is simple:
$R$ is the transitive closure of ``there is a pointer from $x$ to $y$'' on $R\sb{0}$.
We call identifying $R$ for \emph{reachability analysis}. By then tracking all allocated blocks
$A$, we can identify the set of unreachable block $U$ by taking the relative complement of $R$ in
$A$: $U = A \setminus R$.


When performing the reachability analysis in a concurrent systems, simply following pointers while
maintaining a frontier of unvisited blocks is not sufficient. Since there are multiple threads in
the system, some other thread $T'$ may come along and change pointers, causing reachable blocks to
be observed as unreachable by the reclaiming thread, as shown in \cref{fig:pointer-swap}.
 
\begin{figure}[ht]
  \centering
  \input{figures/pointer-swap}
  \caption{Mutation in the memory graph may lead to reachable blocks being observed as
  unreachable.\label{fig:pointer-swap}}
\end{figure}

In order to handle mutation problems, we obtain a snapshot of the entire processes memory by
freezing all threads, reading their roots, and forking the process. Thus, we have a snapshot of
the entire memory of the program, in which we also have all roots. Now the reachability analysis is
simpler, since there will be only one thread in the forked process, namely the garbage collecting
thread. \cref{lst:cmr} shows pseudocode for both the reclaiming thread and the other threads
for this procedure.

\begin{figure}[ht]
  \begin{subfigure}{0.45\textwidth}
    \begin{lstlisting}
CMR():
    freeze_threads()
    wait_for_writes()
    read_guards()
    fork()
    unfreeze()
    for addr in unreachables():
        free(addr)\end{lstlisting}
  \end{subfigure}
  \hfill
  \begin{subfigure}{0.45\textwidth}
    \begin{lstlisting}
on_freeze():
    write_roots()
    register_done()
    wait_for_unfreeze()\end{lstlisting}
  \end{subfigure}
  \caption{Pseudocode of CMR\@. The leftmost code is for the thread that runs the reclamation pass,
  and the rightmost code is other threads in the system.\label{lst:cmr}}
\end{figure}


\fixme{define ``Rust memory'' and shared memory}

\section{Primitives of CMR\label{sec:cmr-primitives}}

The central data type to achieve this is \code{Guard}. A \code{Guard} is an object in which a
pointer to shared memory is stored. All pointers to shared memory are stored in a Guard. By having
access to all \code{Guard}s, CMR have access to all roots in the program at any instant.
\code{Guard}s are similar to \gls{hps} (\cref{sec:hazard-pointers}), except that no thread
synchronization is performed when making new or updating existing \code{Guard}s, which reduces the
overhead of CMR significantly compared to \gls{hps}.

CMR has four types that are essential to understanding how we manage safe access to shared memory:
\emph{Guard}, \emph{Atomic}, \emph{NullablePtr}, and \emph{Ptr}. All types are generic over the
type of the data they protect, which is omitted for brevity.


\begin{definition}[Guard\label{def:guard}]
  A \emph{Guard} is an object that contains a \emph{root} or $\bot$. The Guard is non-movable in
  memory. All roots are stored in Guards.
\end{definition}

\begin{definition}[Atomic]
  An \emph{Atomic} is a pointer type that provides safe concurrent access to its users.
\end{definition}

\begin{definition}[NullablePtr]
  \emph{NullablePtr} is an immutable pointer that may be $\bot$. It is obtained through a Guard.
  When a NullablePtr $p$ is obtained from a Guard $g$, $g$ is immutable thoughout the
  lifetime\footnote{We use the same meaning of lifetime as Rust (\cref{sec:rust-lifetimes})}
  of $p$.
\end{definition}

\begin{definition}[Ptr]
  \emph{Ptr} is an immutable pointer that may \emph{not} be $\bot$. Its semantics are similar to
  that of NullablePtr, but the two are distinct types for simplification of the null-case. All
  accesses to shared memory is through a Ptr.
\end{definition}

These four types are the building blocks of writing concurrent structures in CMR\@. All pointers
are stored in an \mc{Atomic}, and loading an atomic using a \mc{Guard} yields a \mc{NullablePtr},
which may be promoted to a \mc{Ptr}, if it is not null. The \mc{Ptr} provides access to the data
the pointer points to.  In addition to having the types, CMR defines a number of operations that
acts on these types.  We look at each type in turn, and define their operations.

\subsection{Guard}
A Guard can be constructed with the initial value of $\bot$ with \emph{make-guard}
\begin{equation}\label{eq:make-guard}
  \text{make-guard\:::\:} () \to Guard
\end{equation}
It can also copy the value of another Guard with \emph{copy-guard}.
\begin{equation}\label{eq:copy-guard}
  \text{copy-guard\:::\:} (Guard, Guard) \to ()
\end{equation}

General usage of \mc{Guard} is to construct the number of \mc{Guard}s one needs for some operation.
These \mc{Guard}s are then used to load \mc{Atomic}s into.


\subsection{Atomic}

Atomic is a regular atomic pointer variable, supporing operations such as \emph{store}, and
\emph{compare-and-swap}.
\begin{equation}\label{eq:atomic-store}
  \text{store\:::\:} (Atomic, NullablePtr) \to ()
\end{equation}
\begin{equation}\label{eq:atomic-cas}
  \text{compare-and-swap\:::\:} (Atomic, NullablePtr, NullablePtr) \to NullablePtr
\end{equation}

It is not safe to \emph{load} an atomic, as there is no guarantee that the
pointer read is protected by a guard. Instead, CMR defines \emph{load-atomic}, which loads an
Atomic into a Guard, and returns the value read as a NullablePtr:
\begin{equation}\label{eq:load-atomic}
  \text{load-atomic\:::\:} (Guard, Atomic) \to NullablePtr
\end{equation}

\subsection{NullablePtr}

The NullablePtr is just a convenience type in order to not have to handle the $\bot$ case of all
pointers. Whether the pointer is null or not can be checked:

\begin{equation}\label{eq:nullable-is-null}
  \text{is-null\:::\:} (NullablePtr) \to bool
\end{equation}

CMR also supports using the lower bits of a pointer to store extra information (a \emph{tag}). This
is useful for implementing deletion in linked lists, among other things.  The tag is read with
\emph{tag},
\begin{equation}\label{eq:ptr-tag}
  \text{tag\:::\:} (NullablePtr) \to int
\end{equation}
and a new NullablePtr can be constructed with a given tag using \emph{with-tag}.
\begin{equation}\label{eq:ptr-with-tag}
  \text{with-tag\:::\:} (NullablePtr, int) \to NullablePtr
\end{equation}
The actual address is obtained through \emph{addr}
\begin{equation}\label{eq:ptr-addr}
  \text{addr\:::\:} (NullablePtr) \to int
\end{equation}

\subsection{Ptr}

\fixme{Reconsider having NullablePtr in here. I think its mostly a rust impl thing, as we just want
Deref on Ptr but must handle null as well.}
Ptr may be used in the place of NullablePtr, since is it just a special case of it. All functions
that take a NullablePtr can also take a Ptr.


\subsection{Other actions}

We also need a few other operations to make sure that the implementation of funcions are valid.
For instance, in load-atomic there is a window in between reading the atomic and storing the
pointer read it in the guard in which a reclamation pass may have happened. The higher order
function \emph{without_reclamation} makes sure that this is safe, by running the given function
without a reclamation pass happening in between:
\begin{equation}\label{eq:without_reclamation}
  \text{without_reclamation\:::\:} (() \to T) \to T
\end{equation}

As CMR controls memory allocations, it also defines its own allocation function:
\begin{equation}\label{eq:alloc}
  \text{alloc\:::\:} (Guard, T) \to Ptr
\end{equation}


\section{Correctness\label{sec:cmr-correctness}}

With these types and operations we are able to prove important properties of the system.

\begin{theorem}[\mc{Guard} is valid]\label{thm:guard-valid}
  If a \mc{Guard} is not $\bot$, it points to valid memory.
\end{theorem}
\begin{proof}
  Since the \mc{Guard} $g \neq \bot$, it has loaded its value from an Atomic $a$ using
  \mc{atomic-load}.  We first show that $a$ is itself in valid memory by induction: \emph{Base
  case:} the Atomic resides in Rust memory, and is thus valid. \emph{Inductive case:} the
  \mc{Atomic} resides in shared memory, and thus accessed through a \mc{Ptr} $p$.  This \mc{Ptr} is
  protected by a \mc{Guard} $g\sb{2} \neq g$, since $g\sb{2}$ is immutable throughout the lifetime
  of $p$, and $g$ is being changed. $g\sb{2}$ is valid by induction, so the pointer value in $a$ is
  reachable. This shows that the value read from the \mc{Atomic} is valid.

  Using \mc{without_reclamation} (\cref{eq:without_reclamation}), we make sure that the read of $a$
  and the store in $g$ happens without a reclamation pass in between. Thus all valid pointers
  before the read is still valid after the store. After the store operation in $g$ has completed,
  $g$ protects $v$. Thus $v$ is valid.
\end{proof}

\begin{lemma}[\mc{Ptr} is valid]\label{lm:ptr-valid}
  The \mc{Ptr} points to valid memory.
\end{lemma}
\begin{proof}
  The  \mc{Ptr} $p$ is read from a \mc{Guard} $g$ and $g$ is immutable throughout the lifetime of
  $p$ so they have the same value. $p \neq \bot$, so this follows by \cref{thm:guard-valid}.
\end{proof}

\cref{lm:ptr-valid} is the most important result in this section, since it guarantees that
accesses of the memory in a \mc{Ptr} is valid. Thus, a memory access through a \mc{Ptr} can not
result in a invalid-read (\cref{def:invalid-read}) or use-after-free (\cref{def:use-after-free})
hazard.
