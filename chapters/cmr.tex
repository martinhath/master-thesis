\chapter{CMR}

\section{Overview}

The high level idea of the system is for the consolidator to have easy access to all roots in every
thread. With this information, the problem of identifying garbage is equivalent to reachability
analysis in a graph in which the vertices are \code{struct}s and the edges are pointers.
\todo{image here}

The central data type to achieve this is \code{Guard}. A \code{Guard} is an object in which a
pointer to shared memory is stored. By having access to all \code{Guard}s, CMR have access to all
roots. \code{Guard}s are similar to hazard pointers, except that no thread synchronization is
performed when making new or updating existing \code{Guard}s, which reduces the overhead
significantly.

\vspace{2cm}

\todo{define ``Rust memory'' and shared memory}

\section{some name here}

CMR has four types that are essential to understanding how we manage safe access to shared memory:
\emph{Guard}, \emph{Atomic}, \emph{NullablePtr}, and \emph{Ptr}. All types are generic over the
same type, which is omitted for brevity. We look at each type in turn.

\begin{definition}[Guard]
  A \emph{Guard} is an object that contains a \emph{root}. The Guard is non-movable in memory.
  All roots are stored in Guards.
\end{definition}

\begin{definition}[Atomic]
  An \emph{Atomic} is a pointer variable that provides safe concurrent access.
\end{definition}

\begin{definition}[NullablePtr]
  \emph{NullablePtr} is an immutable pointer that may be $\bot$. It is obtained through a Guard.
  When a NullablePtr $p$ is obtained from a Guard $g$, $g$ is immutable thoughout the lifetime of
  $p$.
\end{definition}

\begin{definition}[Ptr]
  \emph{Ptr} is an immutable pointer that may \emph{not} be $\bot$. Its semantics are similar to
  that of NullablePtr, but the two are distinct types for simplification. All accesses to shared
  memory is through a Ptr.
\end{definition}


Having defined the types, we define the operations on the types:

\begin{definition}[Common operations]
\begin{equation}\label{eq:make-guard}
  \text{make-guard\:::\:} () \to Guard
\end{equation}
\emph{make-guard} constructs a new Guard variable containing $\bot$.

\begin{equation}\label{eq:load-atomic}
  \text{load-atomic\:::\:} (Guard, Atomic) \to NullablePtr
\end{equation}
\emph{load-atomic} reads the atomic vairable, protects it with the Guard, and return a NullablePtr
to the value read.
\end{definition}

\begin{definition}\label{def:atomic}
  $\text{atomic\:::\:} (() \to T) \to T$ is a higher order function that runs a function without
  a reclamation pass happening during the functions execution.
\end{definition}




With these types and operations we are able to prove important properties of the system.

\begin{theorem}[Guard is valid]\label{thm:guard-valid}
  If a Guard is not $\bot$, it points to valid memory.
\end{theorem}
\begin{proof}
  \note{lol}
  Assume the Guard $g$ $\neq \bot$.
  The Guard has loaded its value from an Atomic $a$ using $atomic-load$.
We first show that $a$ is itself in valid memory. By induction:
\emph{Base case:} the Atomic resides in Rust memory, and is thus valid. \emph{Inductive case:} the
Atomic resides in shared memory, and thus accessed through a Ptr $p$.  This Ptr is protected by a
Guard $g\sb{2} \neq g$, since $g\sb{2}$ is immutable throughout the lifetime of $p$, and $g$ is
being changed. $g\sb{2}$ is valid by induction, so the pointer value in $a$ is reachable.

Using Definition~\ref{def:atomic}, we make sure that the read of $a$ and the store in $g$ happens
without a reclamation pass in between. Thus all valid pointers before the read is still valid after
the store.  After the store operation in $g$ has completed, $g$ protects $v$. Thus $v$ is valid.
\end{proof}

\begin{lemma}[Ptr is valid]\label{lm:ptr-valid}
  The Ptr points to valid memory.
\end{lemma}
\begin{proof}
The  Ptr $p$ is read from a Guard $g$ and $g$ is immutable throughout the lifetime of $p$ so they
have the same value. $p \neq \bot$, so this follows by Theorem~\ref{thm:guard-valid}.
\end{proof}


\section{Implementation}

\note{Add implementation details here}

  \code{WAS\_SIGNALED} is a thread local flag that is
  set to \code{true} in the signal handler. Note that this function does not support being called
  recursively.
\begin{figure}[ht]
\begin{lstlisting}
fn atomic(f: F):
  loop:
    WAS_SIGNALED = false
    let ret = f()
    if not WAS_SIGNALED: return ret
\end{lstlisting}
\caption{Pseudocode of $atomic$}
\end{figure}
