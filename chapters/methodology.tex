\chapter{Methodology}
\lorem{}


\section{Development}
\lorem{}


\section{Testing}

Testing is an important part of sfotware development. While formal methods have not yet made its
way into the software development insdustry, simpler and more heuristic methods, like unit testing
and integration testing, are widespread. However, as Edsger Dijkstra famously said: ``Testing shows
the presence, not the absence of bugs''\cite{buxton1970software}; while testing is useful to
improve the quality of software, it is far from sufficient.

In the world of concurrent programming this is even less so. Many bugs are manifested through
unfortunate\footnote{Some would call interleavings that reveal bugs fortunate} thread execution
interleavings done by the scheduler. We try to reveal these interleavings by repeatedly running
tests until our confidence that no such interleavings exists is sufficiently high. In addition, we
run tests with tools such as Valgrind\cite{valgrind} and our own sanitizer (\cref{sec:sanitizer}).
Tests were also ran with and without compiler optimizations, as these optimizations often reveal
yet more bugs.


\subsection{Sanitizer\label{sec:sanitizer}}

To automate validation of pointer reads we made a compile time feature\footnote{\emph{features} are
similiar to \code{\#ifdef}s in C and C++} called \code{sanitize} that tracked all allocations,
frees, and pointer reads.  Allocations and frees were tracked in two \code{HashMap}s,
\code{ALLOCATIONS} and \code{FREES}.  On each new allocation, we insert it into the \code{HashMap}
while asserting that it was not there previously. We also remove it from the frees map, in case it
had previously been allocated and freed. Since we are using a custom pointer type, \code{Ptr},
checking the validity on each pointer access is possible, as shown in \cref{lst:ptr-sanitize}.

\begin{lstlisting}
pub fn alloc<'a, T: Trace>(t: T) -> Ptr<'a, T> {
    let addr = B::into_raw(B::new(t)) as usize;
    #[cfg(feature = "sanitize")] {
        let mut a = ALLOCATIONS.lock().unwrap();
        assert!(a.insert(addr));
        let mut f = FREES.lock().unwrap();
        f.remove(&addr); }
    unsafe { Ptr::new(addr) } } \end{lstlisting}

\begin{figure}[ht]
\begin{lstlisting}[label=lst:ptr-sanitize,caption=Verifying all pointer accesses with
\code{sanitize}]
impl<'a, T> Deref for Ptr<'a, T> {
    type Target = T;
    fn deref(&self) -> &T {
        #[cfg(feature = "sanitize")] {
            let a = ::alloc::ALLOCATIONS.lock().unwrap();
            if !a.contains(&addr(self)) {
                let was_freed = ::alloc::FREES.lock().unwrap().contains(&addr(self));
                panic!("{:x} is not valid. Was is freed? {}", self.data, was_freed); } }
        unsafe { &*(self.as_raw()) } } }\end{lstlisting}
\end{figure}

\section{Benchmarking}

The benchmarks are ran with 5 second trials, where a function is ran repeatedly for the duration
with any specified number of threads. The number of executions is counted for each thread and
the total operations per second is reported. All threads run the same code, but they may have
different thread local data. This is useful when benchmarking \code{HashMap::insert}, so that the
threads can inserts values with different keys.

There are a number of pitfalls when it comes to benchmarking code. We discuss a few of them;
\cite{rare} is a good resource for experimental testing of data structures.

Initialization of data structures should not be done on a single core as this creates
a strong skew of data locality for that core, and other cores will have reduced performance due to
the data locality. This is especially important on systems with multiple CPU sockets.




\subsection{Trench}

In order to more effectively benchmark threaded applications, an open source benchmarking library
called \code{trench}\cite{trench} was developed. The library handles thread management and state
for the runs of the benchmark. Trench supports both mutable thread local state and immutable shared
state between all threads. For CMR this is useful since we can put the data strucutres we want to
benchmark in the immutable shared state, as neither of the operations we want to test are
\code{\&mut self} (see \cref{sec:concurrency-and-aliasing}). The user specifies the function to be
benchmarked, the number of threads, and the states, and the duration of the benchmark, and
\code{trench} handles the rest. The number of runs of the function specified during the given
duration is measured.  \cref{lst:trench-ex} shows the benchmark for \code{HashMap::insert}.
\code{RandomSource} allows us to pregenerate random numbers that we can insert into the hashmap,
such that the random number generation itself is thread local, and is not included in the
benchmarking loop.

\begin{figure}[ht]
\begin{lstlisting}[label=lst:trench-ex,caption=\code{Hashmap::insert} benchmark using \code{trench}]
fn hashmap_insert(num_threads: usize) {
    fn func(state: &HmState, local: &mut RandomSource<u64>) {
        state.hashmap.insert(local.next(), 0); }
    let b = trench::TimedBench::<HmState, RandomSource<u64>>::with_threads(num_threads);
    b.with_local_state(|l| { cmr::thread_activate();
                             l.gen_n(10_000_000); });
    let res = b.run_for(duration(), func);
    b.with_local_state(|_| cmr::thread_deactivate());
    println!("cmr::HashMap\tinsert\t{} ops/sec", fmt_thousands_sep(res.ops_per_sec)); }
\end{lstlisting}
\end{figure}

The \code{with_local_state} function runs the closure on each thread in parallel; this is used both
for initializing the local state, and for thread local initialization and destruction.
The global and local states, \code{HmState} and \code{RandomSource}, implements the trait
\code{Default}, so that we do not have to initialize it ourselves.
